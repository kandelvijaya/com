<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Swift3 on Kandelvijaya</title>
    <link>http://kandelvijaya.com/tags/swift3/</link>
    <description>Recent content in Swift3 on Kandelvijaya</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Vijaya P. Kandelvijaya</copyright>
    <lastBuildDate>Sun, 28 May 2017 18:43:48 +0200</lastBuildDate>
    
	<atom:link href="http://kandelvijaya.com/tags/swift3/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Functor: Mapping over things!</title>
      <link>http://kandelvijaya.com/2017/05/28/fp-functor/</link>
      <pubDate>Sun, 28 May 2017 18:43:48 +0200</pubDate>
      
      <guid>http://kandelvijaya.com/2017/05/28/fp-functor/</guid>
      <description>Prelude Specialization is the key to mastery; functional programming specializes only on function. Thats all there is. The mastery with FP is to reduce complexity, which is what software engineering is all about. Don&amp;rsquo;t get me wrong, Software engineering is also about delivering product not only over engineering. Delivering real world products used to be the stressful part about functional programming. Not anymore.
Specialization on functions creates a whole new paradigm.</description>
    </item>
    
    <item>
      <title>Testing Network Calls with URLProtocol</title>
      <link>http://kandelvijaya.com/2017/04/30/urlprotocolandunittesting/</link>
      <pubDate>Sun, 30 Apr 2017 00:45:00 +0200</pubDate>
      
      <guid>http://kandelvijaya.com/2017/04/30/urlprotocolandunittesting/</guid>
      <description>URLProtocol and Unit Testing  An NSURLProtocol object handles the loading of protocol-specific URL data. The NSURLProtocol class itself is an abstract class that provides the infrastructure for processing URLs with a specific URL scheme. You create subclasses for any custom protocols or URL schemes that your app supports.
 The main point is:
 All you have to do is define your protocol class and call the registerClass(_:) class method during your app’s launch time so that the system is aware of your protocol.</description>
    </item>
    
    <item>
      <title>Why String Manipulation is alien in Swift3?</title>
      <link>http://kandelvijaya.com/2016/10/11/swiftstringrange/</link>
      <pubDate>Tue, 11 Oct 2016 21:57:04 +0200</pubDate>
      
      <guid>http://kandelvijaya.com/2016/10/11/swiftstringrange/</guid>
      <description>Objective-C era  NSRange has a very simple API. Finding a range, replacing, splitting or chopping are some few tricks off the bat for simple string manipulation. Objective-C and its idiomatic NSRange API looks such:
 public struct _NSRange { public var location: Int public var length: Int }  Lets say we wanted to extract just the name from a JSON string we got.
let a: NSString = “name: Bj P.</description>
    </item>
    
    <item>
      <title>Why Any Hashabel Swift3</title>
      <link>http://kandelvijaya.com/2016/10/10/swift3-why-anyhashable-how-does-it-work-internally/</link>
      <pubDate>Mon, 10 Oct 2016 21:57:04 +0200</pubDate>
      
      <guid>http://kandelvijaya.com/2016/10/10/swift3-why-anyhashable-how-does-it-work-internally/</guid>
      <description>Evolution is predominant. Struggle for Survival applies to just anything that you see. Swift Programming Language is not an exception. Swift continues to change, evolve and mature over time. We can keep our feet wet, migrating year after year to Swift X version. I would. If it strives to be better. This years, Swift 2 -&amp;gt; Swift 3 was little more than a mini project. We saw lots of changes.</description>
    </item>
    
    <item>
      <title>Xcode8 ZStyle Code Formatter: How to write consistent styled code?</title>
      <link>http://kandelvijaya.com/2016/10/10/xcode-code-zstyle-code-formatter/</link>
      <pubDate>Mon, 10 Oct 2016 21:57:04 +0200</pubDate>
      
      <guid>http://kandelvijaya.com/2016/10/10/xcode-code-zstyle-code-formatter/</guid>
      <description>Yet again somebody missed to insert a empty line before the end of file, I missed to provide a empty space after dictionary Key [AnyHashable:Any] and you might miss to leave any of these kinds of code:
//....... return data } func compute(a:Int,b:Int)-&amp;gt;Int{ //.......  Which should have been:
//....... return data } func compute(a: Int, b: Int) -&amp;gt; Int { //.......  So you see where I&amp;rsquo;m heading with this.</description>
    </item>
    
  </channel>
</rss>