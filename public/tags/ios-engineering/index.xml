<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Ios Engineering on Kandelvijaya</title>
    <link>http://kandelvijaya.com/tags/ios-engineering/</link>
    <description>Recent content in Ios Engineering on Kandelvijaya</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Vijaya P. Kandelvijaya</copyright>
    <lastBuildDate>Tue, 11 Oct 2016 21:57:04 +0200</lastBuildDate>
    <atom:link href="http://kandelvijaya.com/tags/ios-engineering/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Why String Manipulation is alien in Swift3?</title>
      <link>http://kandelvijaya.com/2016/10/11/swiftstringrange/</link>
      <pubDate>Tue, 11 Oct 2016 21:57:04 +0200</pubDate>
      
      <guid>http://kandelvijaya.com/2016/10/11/swiftstringrange/</guid>
      <description>

&lt;h1 id=&#34;objective-c-era&#34;&gt;Objective-C era&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;NSRange has a very simple API.
Finding a range, replacing, splitting or chopping are some few tricks off the bat for simple string manipulation. Objective-C and its idiomatic NSRange API looks such:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;public struct _NSRange {
    public var location: Int
    public var length: Int
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Lets say we wanted to extract just the name from a JSON string we got.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let a: NSString = ‚Äúname: Bj P. Kandel‚Äù
let name = a.substring(from: (‚Äúname: ‚Äú as NSString).length)
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;swift3-era&#34;&gt;Swift3 Era&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;let aSwift = ‚Äúname: Bj P. Kandel‚Äù
let nameSwift = aSwift.substring(from: &amp;lt;String.Index&amp;gt;) 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;so-what-is-the-mess-with-string-index&#34;&gt;So what is the mess with String.Index?&lt;/h2&gt;

&lt;p&gt;NSString (and its NSRange) is not unicode aware. Swift intends to have great support for unicode. But do we care?&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If you like Emoji then you do.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;let emojiOBJC: NSString = ‚Äúü§ì‚Äù
emojiOBJC.length   //2 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can see the emoji is actually 1 character for you and our user. But NSString doesn‚Äôt co-relate to natural understanding. It thinks its 2 character. If we were to substring the Emoji, we could get this familiar unknown representation symbol.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;emojiOBJC.substring(from: 1) //ÔøΩ 
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;why&#34;&gt;Why?&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;NSString&lt;/code&gt; uses &lt;code&gt;UTF-16&lt;/code&gt; or 16 bits to encode a character into memory. When reading, &lt;strong&gt;16 bit of memory is treated as 1 character&lt;/strong&gt;. So to find the length of a string, count the 16 bit memory. Straightforward. Shall we think a bit more.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;16 bits == 2^16 possibilities == 65536 distinct characters that can be represented uniquely&lt;/p&gt;

&lt;p&gt;However, There are roughly 6,500 spoken languages in the world today. However, about 2,000 of those languages have fewer than 1,000 speakers. The most popular language in the world is Mandarin Chinese.  &lt;strong&gt;This 16 bit cannot all the characters from all of those language + emojis&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;That‚Äôs why Swift String were made more &lt;strong&gt;unicode&lt;/strong&gt; correct. Unicode is somehow not limited to specify &lt;code&gt;16 bits&lt;/code&gt; for 1 Character or &lt;code&gt;64 bits&lt;/code&gt; . It doesn‚Äôt matter if a üòò takes &lt;code&gt;32 bit&lt;/code&gt; or &lt;code&gt;128 bit&lt;/code&gt;(&lt;em&gt;just example&lt;/em&gt;) for user.  You, me and the other developers. Its 1 character afterall.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Hence, counting X bit memory to find number of characters went like PUFF! Length didn‚Äôt make sense.&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let swiftyEmoji = (emojiOBJC as String)
(emojiOBJC as String).characters.count   // 1
(emojiOBJC as String).utf16.count        // 2 :: like the Objc length
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you think swift treats all characters as &lt;code&gt;32 bit&lt;/code&gt; memory then thats wrong. We don‚Äôt care how it stores. The interface that swift provides is what we care.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;‚Äúgo‚Äù.characters.count   //2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For us, developers, &lt;code&gt;&amp;quot;go&amp;quot;&lt;/code&gt; is 2 character String. So is &lt;code&gt;&amp;quot;üçªüëØ&amp;quot;&lt;/code&gt; is 2 character String. Swift manages the details for us. &lt;strong&gt;String.characters&lt;/strong&gt; provides the most unicode aware interface to us. However, feel free to visit the UTF16 and UTF8 view. Remember those are just a &lt;code&gt;VIEW&lt;/code&gt; to the String.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;‚Äúgo‚Äù.utf16.count        //2
‚Äúgo‚Äù.utf8.count         //2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Okay lets move on to substring some Swifty String. And came swifty &lt;code&gt;Range&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;swifty-string-manipulation&#34;&gt;Swifty String Manipulation&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;public struct Range&amp;lt;Bound : Comparable&amp;gt; {
    public let lowerBound: Bound
    public let upperBound: Bound
    public init(uncheckedBounds bounds: (lower: Bound, upper: Bound))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So substring operation becomes:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;‚ÄúMr. X‚Äù.substring(from: &amp;lt;String.Index&amp;gt;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Like we discussed we cannot just consider a Swift String as Array of Fixed Length Bits; like C &lt;code&gt;char*&lt;/code&gt; where char is 8 bit. Thus, to not chop our emoji, we need a unicode safe way. Swift provides &lt;code&gt;String.Index&lt;/code&gt;. You cannot get the &lt;code&gt;Int&lt;/code&gt; from the &lt;code&gt;String.Index&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;the-details&#34;&gt;The details&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;This will be updated in the coming days.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;some-observations&#34;&gt;Some Observations&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;There is no public API that turns &lt;code&gt;Range&amp;lt;Bounds&amp;gt;&lt;/code&gt; to &lt;code&gt;NSRange&lt;/code&gt; primarily because &lt;code&gt;lowerBound&lt;/code&gt; and &lt;code&gt;upperBound&lt;/code&gt; are not &lt;code&gt;Int&lt;/code&gt; and hence not convertible to &lt;code&gt;Int&lt;/code&gt;.&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Its however trivial to make &lt;code&gt;Range&lt;/code&gt; from &lt;code&gt;NSRange&lt;/code&gt; although you cant make a range without actually specifying whose Range is this. In our case its String.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public extension NSRange {
    func toRange(forString: String) -&amp;gt; Range&amp;lt;String.Index&amp;gt; {
         let lowerIndex = forString.index(forString.startIndex, offsetBy: location)
         let upperIndex = forString.index(forString.startIndex, offsetBy: location + length)
         return Range(uncheckedBounds: (lowerIndex, upperIndex))
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Like above you need to specify WhoseRange to create startIndex and endIndex.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Range created for one string shouldn‚Äôt be used to manipulate another string directly. In essence, range is tightly owned and is applicable to its owner only.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let a = ‚Äúthis iz it‚Äùlet aor = a.range(of: ‚Äúiz‚Äù)!
var another = ‚Äúth iz it‚Äùanother.replaceSubrange(aor, with: ‚ÄúIS‚Äù) //OUTPUT =‚ÄúthISz it‚Äù
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If we wanted to offset by +1 and use the same range then it can be done as such&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func rangeFrom(range: Range&amp;lt;String.Index&amp;gt;, forString: String, offset: Int) -&amp;gt; Range&amp;lt;String.Index&amp;gt; {
     let lowerIndex = forString.index(range.lowerBound, offsetBy: offset)
     let upperIndex = forString.index(range.upperBound, offsetBy: offset)
     returnRange(uncheckedBounds: (lowerIndex, upperIndex))
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;In the above code, range is calculated from another string.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let nr = rangeFrom(range: aor, forString: another, offset: 1)
another.replaceSubrange(nr, with: ‚ÄúIS‚Äù) //OUTPUT = ‚Äúth IS it‚Äù
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The above rangeFrom function will produce error such as these:&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;When the lower/upperBounds of the fromString are computed which will fall outside of the range of the entire fromString.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//fatal error: cannot decrement invalid index
//fatal error: cannot increment beyond endIndex
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;should-we-use-simple-nsrange-and-nsstring-or-go-through-swifty-pain-to-be-unicode-aware&#34;&gt;Should we use simple &lt;code&gt;NSRange&lt;/code&gt; and &lt;code&gt;NSString&lt;/code&gt; or go through swifty pain to be unicode aware?&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;No support for üòéüíî&lt;/li&gt;
&lt;li&gt;No support for Image Literals and other literals Apple will add on with time.&lt;/li&gt;
&lt;li&gt;Only supports with reasoning when UTF16 is used&lt;/li&gt;
&lt;li&gt;When there is a emoji like üíî  it will be counted as 2 characters if you use NSRange api and it gets worse if you try to insert a space in-between those 2 characters.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This all depends on your use case. If you are sure there are not special characters and emojis involved in the text then &lt;code&gt;UTF-16&lt;/code&gt; suffices for english languages. However, the more cryptic and global your content is the more precaution is needed. After all, Swift does all the heavy lifting, you just don‚Äôt get the &lt;code&gt;Int&lt;/code&gt; for &lt;code&gt;lowerbound&lt;/code&gt; and &lt;code&gt;upperbound&lt;/code&gt;.  Why not deal with it?&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Why Any Hashabel Swift3</title>
      <link>http://kandelvijaya.com/2016/10/10/swift3-why-anyhashable-how-does-it-work-internally/</link>
      <pubDate>Mon, 10 Oct 2016 21:57:04 +0200</pubDate>
      
      <guid>http://kandelvijaya.com/2016/10/10/swift3-why-anyhashable-how-does-it-work-internally/</guid>
      <description>

&lt;p&gt;Evolution is predominant. Struggle for Survival applies to just anything that you see. Swift Programming Language is not an exception. Swift continues to change, evolve and mature over time. We can keep our feet wet, migrating year after year to Swift X version. I would. If it strives to be better. This years, &lt;code&gt;Swift 2 -&amp;gt; Swift 3&lt;/code&gt; was little more than a mini project. We saw lots of changes. For this edition, we will focus on &lt;code&gt;[AnyObject: NSObject]&lt;/code&gt;, which became &lt;code&gt;[AnyHashable: Any]&lt;/code&gt;. So does JSON, NSArray and NSDictionary. But why? We will dive deep, bear with me.&lt;/p&gt;

&lt;h1 id=&#34;anyobject-any&#34;&gt;AnyObject -&amp;gt; Any&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;Swift focuses on using Value Types / immutable type in all cases possible. Foundation in Objective-C, has in other hand, all reference type. Classes. Which will be imported into reference type in swift.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;AnyObject&lt;/code&gt; is idomatially ObjectiveC flavored and is reference type.&lt;/li&gt;
&lt;li&gt;Swift is platfrom independent, it had to move away from relying on ObjectiveC idioms and its runtime. Hence &lt;code&gt;AnyObject&lt;/code&gt; had to be replace with Value type and Swift flovored &lt;code&gt;Any&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;some-more-thoughts&#34;&gt;Some more thoughts&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Any&lt;/code&gt; is value type. (We will see how it actually is boxing refernce but is Value type later on)&lt;/li&gt;
&lt;li&gt;All Objective-C Foundation &lt;code&gt;id&lt;/code&gt; types will be imported as &lt;code&gt;Any&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;All Swift types including Enum and Struct can be bridged to Objective-C as &lt;code&gt;id&lt;/code&gt;. This id is minimal.&lt;/li&gt;
&lt;li&gt;All Swift types that were bridged to Objective-C &lt;code&gt;id&lt;/code&gt; can be bridged back to &lt;code&gt;Swift&lt;/code&gt; as &lt;code&gt;Any&lt;/code&gt; or casted to their previous Type. Swift doesnot remove the type information during the boxing; internally.&lt;/li&gt;
&lt;li&gt;For Example:&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;enum Direction2 : String {

    case down = &amp;quot;UP&amp;quot;
    case up = &amp;quot;DOWN&amp;quot;
}
var objcArray = NSMutableArray() // [NSObject, NSObject] or [id, id]
var swiftEnum = Direction2.down
objcArray.add(swiftEnum)

objcArray.lastObject as? Direction2     //down
objcArray.lastObject as? NSString //nil
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;nsobject-anyhashable-consider-the-situation&#34;&gt;NSObject -&amp;gt; AnyHashable Consider the situation -&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;[NSObject: AnyObject]&lt;/code&gt;. This turned into &lt;code&gt;[NSObject: Any]&lt;/code&gt;.
*   Its natural to get rid of &lt;code&gt;Object&lt;/code&gt; feeling. Afterall, &lt;code&gt;AnyObject&lt;/code&gt; became &lt;code&gt;Any&lt;/code&gt;.
*   Like before, we wanted to work with Value types. NSObject does 2 things which we want to avoid.
    *   It is a reference type. (There is also NSObjectProtocol)
    *   It requires us to know about ObjectiveC idiom. Swift is again platform independent.
*   A &lt;code&gt;Dictionary&lt;/code&gt;, &lt;code&gt;Array&lt;/code&gt; , &lt;code&gt;Set&lt;/code&gt; expects Key/Element to be &lt;code&gt;Hashable&lt;/code&gt;. There is no requirement it can just be some few types.
*   Hence, its more fluid to represent somewhat alien &lt;code&gt;[NSObject: AnyObject]&lt;/code&gt; with &lt;code&gt;[AnyHashable, Any]&lt;/code&gt;.
*   Wait. Why not &lt;code&gt;[Hashable: Any]&lt;/code&gt;? Good question. Lets see.&lt;/p&gt;

&lt;h2 id=&#34;why-not-hashable-any&#34;&gt;Why not &lt;code&gt;[Hashable: Any]&lt;/code&gt;?&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;Hashable&lt;/code&gt; conforms to &lt;code&gt;Equatable&lt;/code&gt; Protocol which has &lt;code&gt;==&lt;/code&gt; method requirement which has a &lt;code&gt;Self&lt;/code&gt; associated type. &lt;code&gt;public static func ==(lhs: Self, rhs: Self) -&amp;gt; Bool&lt;/code&gt; Hence, &lt;code&gt;Hashable&lt;/code&gt; can only be used to contraint Generic Types but not be used as a Concrete Type. (For more on this &lt;code&gt;Generic&lt;/code&gt; issue follow this &lt;strong&gt;link&lt;/strong&gt;. ) Thus we need a &lt;strong&gt;concrete type conforming to Hashable&lt;/strong&gt; that can fit into the Key of dictionary. We also need to enable heteregeneous collection because it needs to bridge to the Objective-C API NSArray and NSDictionary. Hence, we need a type erased container that confroms to &lt;code&gt;Hashable&lt;/code&gt; to be used inplace of &lt;code&gt;NSObject&lt;/code&gt;. That contianer is &lt;code&gt;AnyHashable&lt;/code&gt;.&lt;/p&gt;

&lt;h1 id=&#34;internals-of-anyhashable-if-you-already-know&#34;&gt;internals of AnyHashable If you already know&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Boxing&lt;/strong&gt; (I mean data boxing. Very essential technique.) and have something else to do, you can stop here. Okay, seems like you want to do &lt;strong&gt;Boxing&lt;/strong&gt;. Lets dig a little deep to see how and what &lt;code&gt;AnyHashable&lt;/code&gt; does? Better yet, lets simulate a similar &lt;code&gt;Any2Hashable&lt;/code&gt; together.&lt;/p&gt;

&lt;h2 id=&#34;boxing-it-is-a-technique-of-wrapping-a-object-inside-another-container-type-it-has-nothing-to-do-with&#34;&gt;Boxing It is a technique of wrapping a Object inside another container type. It has nothing to do with&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;Decorator&lt;/code&gt; pattern but you are on track. The best example of this is &lt;code&gt;Optional&amp;lt;Wrapped&amp;gt;&lt;/code&gt; type. It takes anything and wraps it around with &lt;code&gt;Optional&lt;/code&gt; enum. This gets rid of lots of assumptions we used to do in &lt;code&gt;Objective-C&lt;/code&gt;. We will see how &lt;code&gt;AnyHashable&lt;/code&gt; boxes in the following section.&lt;/p&gt;

&lt;h3 id=&#34;step-1-basic-implementation-then-a-naive-way-to-wrap-this-or-box-all-hashable-conformed-type-would-be-such&#34;&gt;Step 1: Basic implementation Then a naive way to wrap this or box all Hashable conformed type would be such.&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;struct Any2Hashable : Hashable {
    private var _box: Any

    var hashValue: Int {
        //LOOKOUT 1
        return (_box as? Hashable)?.hashValue ?? 0
    }

    public static func ==(_ lhs: Any2Hashable, _ rhs: Any2Hashable) -&amp;gt; Bool {
        return lhs.hashValue == rhs.hashValue
    }

    init?(_ any: Any) {
        //LOOKOUT 2
        if let thatAny = any as? Hashable {
            _box = thatAny
        }
        return nil
    }
}
 However, for 2 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;lookout&lt;/code&gt; the compiler gives us this error and stops from any real success.
    //ERROR: Protocol Hashable can only be used as genric constraint because it has Self or associated type requirements
     These should throw back some lightbulbs. Its simple way of saying Hashable is just a Generic Type not a complete one. Because it conforms to Equatable which has Self requirements.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://kandelvijaya.com/index.php/2016/06/24/comparision-of-swift-programming-language-on-the-support-for-generics/&#34;&gt;To read more on Generics&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;step-2-improvement-with-generics&#34;&gt;Step 2: Improvement with Generics&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;struct Any2Hashable{
    var _box: Any
    private var _hashValue: Int

    var hashValue: Int {
        return _hashValue
    }

    public static func ==(_ lhs: Any2Hashable, _ rhs: Any2Hashable) -&amp;gt; Bool {
        return lhs.hashValue == rhs.hashValue
    }

    init&amp;lt;T: Hashable&amp;gt;(_ base: T) {
        _box = base
        _hashValue = base.hashValue
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will compile fine and work too. However, Swift stdlib has a longer implementation for a reason. Lets take a look at a scenario before proceeding.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let iHA = Any2Hashable(12)
let i2HA = Any2Hashable(UInt8(12))
let sHA = Any2Hashable(&amp;quot;bj&amp;quot;)
iHA == sHA     // FALSE
iHA == i2HA    // TRUE :: Lookout
 As you can see, although the first comparion looks correct, the second one is somewhat a lie. 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Swift is TypeSafe&lt;/strong&gt;. &amp;ldquo;A Int with 12 is not equal with Int8 with 12.&amp;rdquo; The underlying memory representation are different and it should not be equal. Although it seems. With our implementation of Any2Hashable we completely ignored the underlying type for sake of brevity. However, Swift standard library goes in length to fix this subtle fact.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let swiftInt64Hashable = Int(12) as AnyHashable
let swiftInt8Hashable = Int8(12) as AnyHashable
swiftInt8Hashable == swiftInt64Hashable  // FALSE
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We shall see how do they actually preserve type info during the comaprision although AnyHashable, from the outside, is a type erased container for Hashable.&lt;/p&gt;

&lt;h3 id=&#34;step-3-bringing-back-the-type-info&#34;&gt;Step 3: Bringing back the Type info&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;_box: Any&lt;/code&gt; is limiting us from type checking in our current implementation. What if we wrap the value that is being sent to initializer into a concrete internal struct. We could be on the way to storing typed type.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct Any2Hashable{
    //LOOKOUT
    var _box: _InternalConcreteBox

    init&amp;lt;T: Hashable&amp;gt;(_ base: T) {
        _box = _InternalConcreteBox(base)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nothing has changed here except we got rid of other helper methods to be concise.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct _InternalConcreteBox&amp;lt;Base: Hashable&amp;gt; {

    var _baseHashable: Base
    var _hashValue: Int {
        return _baseHashable.hashValue
    }

    init(_ base: Base) {
        _baseHashable = base
    }

    //more code....
}
 Although in the right direction, Compiler wont allow us to use 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;_InternalConcreteBox&lt;/code&gt; as concrete type for &lt;code&gt;_box&lt;/code&gt; as this is a Generic Placeholder and incomplete Type (like before). Other than that everything looks good. We could say, &lt;code&gt;_InternalConcreteBoc&lt;/code&gt;_ is bocing a Type but it tries to preserve the original type info. Whereas, &lt;code&gt;Any2Hashable&lt;/code&gt; is a type erased container.&lt;/p&gt;

&lt;h3 id=&#34;step-4-solving-generics-yet-again-with-protocol-one-way-to-solve-this-issue-is-by-providing-a-complete-protocol-conformance-with-the-required-methods-like-so&#34;&gt;Step 4: Solving Generics yet again with Protocol One way to solve this issue is by providing a complete Protocol Conformance with the required methods like so:&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;protocol _Any2HashableBox {
    var _hashValue: Int { get }
    func _isEqual(to: _Any2HashableBox) -&amp;gt; Bool?
}
 and the Internal Box looks like so. Then we can use 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;_Any2HashableBox&lt;/code&gt; as complete type. &lt;code&gt;struct _InternalConcreteBox&amp;lt;Base: Hashable&amp;gt;: _Any2HashableBox { ‚Ä¶.&lt;/code&gt; While at our Any2Hashable site, the below change compiles perfectly.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct Any2Hashable{
    var _box: _Any2HashableBox
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;step-5-typed-equality-finally-now-that-we-have-every-structure-in-place-lets-fill-in-the-isequal-detail&#34;&gt;Step 5: Typed Equality, finally! Now that we have every structure in place, lets fill in the &lt;code&gt;isEqual&lt;/code&gt; detail.&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;struct Any2Hashable{
    var _box: _Any2HashableBox

    public static func ==(_ lhs: Any2Hashable, _ rhs: Any2Hashable) -&amp;gt; Bool {
        return lhs._box._isEqual(to: rhs._box) ?? false
    }

    init&amp;lt;T: Hashable&amp;gt;(_ base: T) {
        _box = _InternalConcreteBox(base)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;protocol-for-boxtype&#34;&gt;Protocol for BoxType&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;protocol _Any2HashableBox {
    var _hashValue: Int { get }
    func _isEqual(to: _Any2HashableBox) -&amp;gt; Bool?
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;concrete-box-struct&#34;&gt;Concrete Box Struct&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;struct _InternalConcreteBox&amp;lt;Base: Hashable&amp;gt;: _Any2HashableBox {

    var _baseHashable: Base
    var _hashValue: Int {
        return _baseHashable.hashValue
    }

    init(_ base: Base) {
        _baseHashable = base
    }

    func _isEqual(to: _Any2HashableBox) -&amp;gt; Bool? {
        //LOOK OUT
        if let other : Base = (to as? _InternalConcreteBox)?._baseHashable {
            return _hashValue == other.hashValue
        }
        return nil
    }

}
 In this 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;//LOOK OUT ::&lt;/code&gt;, we are getting hold of the &lt;code&gt;&amp;lt;Base: Hashable&amp;gt;&lt;/code&gt; that was used to create &lt;code&gt;_InternalConcreteBox&lt;/code&gt;. In swift current implementation this line is replaced by a method &lt;code&gt;_unbox&amp;lt;T:Hashable&amp;gt;() -&amp;gt; T?&lt;/code&gt;. True, it requires deeper hair pulling. The above &lt;strong&gt;lookout&lt;/strong&gt; line retrieves the original type only if it is same concrete underlying type as &lt;code&gt;Base&lt;/code&gt; for self is. Sure, the line is not so clear on how it does in first sight but it uses Type inference to deduce the type while casting. Only if both self and other are same type we check for the hashValue and return. Lets see the tests:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    let iHA = Any2Hashable(12)
    let swiftInt64Hashable = Int(12) as AnyHashable
    let swiftInt8Hashable = Int8(12) as AnyHashable

    swiftInt8Hashable == swiftInt64Hashable  // FALSE
    iHA == Any2Hashable(12)                  // TRUE
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;some-key-learnings&#34;&gt;Some Key Learnings:&lt;/h2&gt;

&lt;p&gt;So far, we have seen how to box types. &amp;ldquo;NOTE: Boxing should be done only when absolutely necessary.&amp;rdquo; We also saw how we can box types that actually preserves their original type and how it can leverage for cases like AnyHashable. This is the whole idea how AnyHashable in Swift core library works. There are other pieces of functionality I havent added just to make the topic concise. They can be found&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/apple/swift/blob/master/stdlib/public/core/AnyHashable.swift&#34;&gt;on Swift github repo page&lt;/a&gt;. They have rich documentation but requires a lot of researching to get to know the why were they created like the way they are. This is how, swift bridges NSArray to [AnyHashable] and NSDictionary to AnyHashable: Any] providing a homogeneous boxed collection to work with.&lt;/p&gt;

&lt;h3 id=&#34;cheers-feel-free-to-edit-this-post-if-needed&#34;&gt;Cheers! Feel free to edit this post, if needed.&lt;/h3&gt;
</description>
    </item>
    
    <item>
      <title>Xcode8 ZStyle Code Formatter: How to write consistent styled code?</title>
      <link>http://kandelvijaya.com/2016/10/10/xcode-code-zstyle-code-formatter/</link>
      <pubDate>Mon, 10 Oct 2016 21:57:04 +0200</pubDate>
      
      <guid>http://kandelvijaya.com/2016/10/10/xcode-code-zstyle-code-formatter/</guid>
      <description>

&lt;p&gt;Yet again somebody missed to insert a empty line before the end of file, I missed to provide a empty space after dictionary Key  &lt;code&gt;[AnyHashable:Any]&lt;/code&gt; and you might miss to leave any of these kinds of code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//.......
    return data
}
func compute(a:Int,b:Int)-&amp;gt;Int{
//.......
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Which should have been:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//.......
return data
}   

func compute(a: Int, b: Int) -&amp;gt; Int {
//.......
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So you see where I&amp;rsquo;m heading with this.&lt;/p&gt;

&lt;h2 id=&#34;bigger-picture&#34;&gt;Bigger Picture&lt;/h2&gt;

&lt;p&gt;To just briefly explain the scenario, we are 12 iOS Engineers working harder than before (pun intended), cramming hundreds of line of code daily.
We have bunch of features to roll out, release deadline to meet and a generation next to come and read the code we wrote with great thought.
We couldn&amp;rsquo;t possibly achieve if, each of us, with unique style  &lt;code&gt;(tabs vs spaces)&lt;/code&gt; worked on. Thus, we have a Zalando iOS coding guidelines.
Which keeps us in the same fashion. But like again, there is no way to actually force the project to have a strict guidelines and we humans are error prone.&lt;/p&gt;

&lt;h2 id=&#34;problem&#34;&gt;Problem&lt;/h2&gt;

&lt;p&gt;Some empty line or no empty spaces sneaks in the code base. We need a tool to correct out the our style to Zalando iOS style.
After all we care, because mainly we are a fashionable technology company. All right!&lt;/p&gt;

&lt;h2 id=&#34;solutions-available&#34;&gt;Solutions Available&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/realm/SwiftLint&#34;&gt;Swift Lint&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;Its a good library but we have some serious issue with it.&lt;/li&gt;
&lt;li&gt;We have a large build time and this adds some more.&lt;/li&gt;
&lt;li&gt;We already have hundreds of TODO and FIXME that are signaling warnings. This adds even more errors/warnings.&lt;/li&gt;
&lt;li&gt;The tool has limited possibility of correction. Our solution is not to give things to the devs to correct. They are already busy. It is to work for them.
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;our-attempt&#34;&gt;Our Attempt&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Before&lt;/strong&gt; WWDC 2016&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Integrate SwiftLint and use regex to auto correct. But still the disadvantage was bigger than advantage.&lt;/li&gt;
&lt;li&gt;Abandoned!
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;After&lt;/strong&gt; WWDC 2016&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Source Kit Extension API announced.&lt;/li&gt;
&lt;li&gt;I started secretly using this extension to auto correct only things we cared.&lt;/li&gt;
&lt;li&gt;The &lt;strong&gt;birth of XcodeFormatter!&lt;/strong&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;xcodeformatter&#34;&gt;XcodeFormatter&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Its a file based auto formatter. It wont warn or error. It just silently formats to the ZStyle. Pretty silently.&lt;/li&gt;
&lt;li&gt;Reach out to the Editor -&amp;gt; XFormatter -&amp;gt; &amp;hellip;(options)&lt;/li&gt;
&lt;li&gt;When you absolutely don&amp;rsquo;t want to, then don&amp;rsquo;t.&lt;/li&gt;
&lt;li&gt;If you want to, which you should, then provide a shortcut or if you are mouse ninja then reach in the Editor  -&amp;gt;&lt;/li&gt;
&lt;li&gt;Done!&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;technical-side&#34;&gt;Technical Side&lt;/h2&gt;

&lt;p&gt;I prefer to run down the tech side by data flow or message flow.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;When user presses, Editor  -&amp;gt; XcodeFormatter  -&amp;gt; Correct All: Xcode sends the file content to our App Extension.&lt;/li&gt;
&lt;li&gt;The app extension, choses a certain formatting method based on the command user clicked.&lt;/li&gt;
&lt;li&gt;Inside the app extension, there are  &lt;code&gt;RegexMatch&lt;/code&gt; and  &lt;code&gt;CodeBlockAnalyzer&lt;/code&gt; which stays at the heart of matching the wrong style.&lt;/li&gt;
&lt;li&gt;Inside the app extension, there are  &lt;code&gt;MatchCorrection&lt;/code&gt; and  &lt;code&gt;EmptyLineCorrection&lt;/code&gt; which stays at the heart of correcting the matched code.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MatchCorrectionInfo&lt;/code&gt; is used to correct the match in case of  &lt;code&gt;MatchCorrection&lt;/code&gt;. Idea is to replace the Capture Group.  &lt;code&gt;MatchCorrectionInfo&lt;/code&gt; provides a  &lt;code&gt;[Int: String]&lt;/code&gt; with int for index of Capture Group and String for what to replace the found match with.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;EmptyLineCorrection&lt;/code&gt; does not need a correction rule as it trivially inserts/removes empty line above/below each  &lt;code&gt;CodePosition&lt;/code&gt; passed into correct.&lt;/li&gt;
&lt;li&gt;All the matches and analyzation happens if the current character in code is not inside a  &lt;code&gt;//Comment&lt;/code&gt; or  &lt;code&gt;&amp;quot;String quote&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;When everything is done, the  &lt;code&gt;XCSourceEditorExtension&lt;/code&gt; gets the corrected data, uses it to put the changes back into the  &lt;code&gt;NSMutableArray&lt;/code&gt; of lines Xcode provided us initially.&lt;/li&gt;
&lt;li&gt;This change is then reflected in Xcode once the completion handler is called.&lt;/li&gt;
&lt;li&gt;Boom! Done!&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;a-more-deeper-level-working-will-be-covered-when-this-article-is-updated&#34;&gt;A more deeper level working will be covered when this article is updated.&lt;/h3&gt;

&lt;p&gt;For details, check the readme file on github. &lt;a href=&#34;https://github.com/kandelvijaya/XcodeFormatter&#34;&gt;XcodeFormatter On Github&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;cheers&#34;&gt;Cheers!&lt;/h2&gt;
</description>
    </item>
    
  </channel>
</rss>