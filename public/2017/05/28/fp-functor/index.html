<!DOCTYPE html>
<html prefix="og: http://ogp.me/ns#">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>Functor: Mapping over things! &middot; kandelvijaya</title>
        <meta name="description" content="Occurances of Functor types in Swift and discussion">
        <meta name="HandheldFriendly" content="True">
        <meta name="MobileOptimized" content="320">
        <meta name="generator" content="Hugo 0.20.2" />
        <meta name="robots" content="index,follow">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta property="og:title" content="Functor: Mapping over things!">
<meta property="og:description" content="Occurances of Functor types in Swift and discussion">
<meta property="og:type" content="article">
<meta property="og:url" content="http://kandelvijaya.com/2017/05/28/fp-functor/">
        <link rel="stylesheet" href="http://kandelvijaya.com/dist/styles.css">
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,400,600,700,300&subset=latin,cyrillic-ext,latin-ext,cyrillic">
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
        
    </head>
    <body>
        
<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-46775685-3', 'auto');
ga('send', 'pageview');
</script>


        <div id="wrapper">
            <header class="site-header">
                <div class="container">
                    <div class="site-title-wrapper">
                        
                            <h1 class="site-title">
                                <a title="Kandelvijaya" href="http://kandelvijaya.com/">Kandelvijaya</a>
                            </h1>
                        
                        <a class="button-square" href="http://kandelvijaya.com/index.xml"><i class="fa fa-rss"></i></a>
                        
                            <a class="button-square button-social hint--top" data-hint="Twitter" title="Twitter" href="https://twitter.com/kandelvijaya">
                                <i class="fa fa-twitter"></i>
                            </a>
                        
                        
                        
                            <a class="button-square button-social hint--top" data-hint="Github" title="Github" href="https://github.com/kandelvijaya">
                                <i class="fa fa-github-alt"></i>
                            </a>
                        
                        
                        
                            <a class="button-square button-social hint--top" data-hint="LinkedIn" title="LinkedIn" href="https://linkedin.com/in/kandelvijaya/">
                                <i class="fa fa-linkedin"></i>
                            </a>
                        
                        
                        
                    </div>

                    <ul class="site-nav">
                        
    <li class="site-nav-item">
        <a title="Blog" href="/post/">Blog</a>
    </li>

    <li class="site-nav-item">
        <a title="GTX Monthly" href="/gtxmonthly/">GTX Monthly</a>
    </li>

                    </ul>
                </div>
            </header>

            <div id="container">


<div class="container">
    <article class="post-container" itemscope="" itemtype="http://schema.org/BlogPosting">
        <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Functor: Mapping over things!</h1>
    
        <p class="post-description" itemprop="description">Occurances of Functor types in Swift and discussion</p>
    
    <p class="post-date">
        <span>Published <time datetime="2017-05-28" itemprop="datePublished">Sun, May 28, 2017</time></span>
        <span>by</span>
        <span itemscope="" itemprop="author" itemtype="https://schema.org/Person">
            <span itemprop="name">
                <a href="" itemprop="url" rel="author">kandelvijaya</a>
            </span>
        </span>
    </p>
</header>

        <div class="post-content clearfix" itemprop="articleBody">
    

    

<h1 id="prelude">Prelude</h1>

<p>Specialization is the key to mastery; functional programming specializes only on function. Thats all there is. The mastery with FP is to reduce complexity, which is what software engineering is all about. Don&rsquo;t get me wrong, Software engineering is also about delivering product not only over engineering. Delivering real world products used to be the stressful part about functional programming. Not anymore.</p>

<p>Specialization on functions creates a whole new paradigm. In FP, there is no overhead to think of object, assignment, mutation, shared data. You are left to think only how you glue functions and keep gluing them until your product is a function of given input that produces output. Imagine a web server written in FP; it would take path and query as input and return the resource located there.</p>

<p>In FP, Function is the unit of reasoning. In OOP, we constructed/invented many cleaver hacks and syntax to get around to solve a particular problem. For instance, we have locks, semaphore, mutex to allow one to do concurrent task while managing a shared resource without deadlocking and getting into race condition. This in itself is a whole new area of study, all because we have mutability. Immutability is de facto in Functional Programming. In such, FP programs can make use of multi cores without any special construct as the order of function execution doesn&rsquo;t really matter.</p>

<p>What is surprising is the amount of new ideas and papers written on how to deal with certain problems in FP is huge compared to what is being done on OOP or imperative programming. For instance, what are all those funky names like Functor, Applicative, Monad, Monoid, etc. My take on this is: what do you do when all you have is a function? Sure enough you examine it extensively, study the properties and try to exploit certain patterns and prove things like Monad can help FP be pure and still do IO.</p>

<blockquote>
<p>The more constraints one imposes, the more one frees one&rsquo;s self. And the arbitrariness of the constraint serves only to obtain precision of execution. - Igor Stravinsky</p>
</blockquote>

<p>FP is of great interest to Academics, Mathematician, Logicians and pragmatic engineer. It however, requires a different attitude and mindset.</p>

<p>I grew up learning QBasic, ActionScript3, C, Java, PHP. I now work on Obj-C/Swift. These all use the same principle to tackle a problem. The imperative style. For comparison, I picked up Python in 1 day. I had to mull over 1 month to get Scheme into my mind and more recently I spent 2 weeks besides work and finally did <code>print(&quot;hello world&quot;)</code> equivalent in Haskell. All the things we know in this Imperative world is useless on the other side, FP world.</p>

<p>In such, FP is not just function composition but equally a different mindset to building software. Similar to the quote;</p>

<blockquote>
<p>If all you have is a hammer, everything looks like nail.</p>
</blockquote>

<p>FP is not a hammer. Its different. We need to tackle problems differently. Read on this awesome paper (The intro section especially) <a href="https://www.cs.kent.ac.uk/people/staff/dat/miranda/whyfp90.pdf">Paper: Why Functional Programming?</a> to get more insight.</p>

<p>I have been learning Haskell intensely for about a month or more now and surprising things do make sense, lately. A lot. I sometimes even feel enlightened temporarily and bemused a bit later thinking; did I got it completely or my mind just ran out of working memory. Its a fascinating paradigm. I will now attempt to show some cool stuffs that I grasped and implement them with Swift. Before I do that, I highly encourage you to go through this <a href="http://wiki.c2.com/?BlubParadox">Blub Paradox Article</a>. I hope you have read it long time ago, every programmer does.</p>

<blockquote>
<p>As long as our hypothetical Blub programmer is looking down the power continuum, he knows he&rsquo;s looking down. Languages less powerful than Blub are obviously less powerful, because they&rsquo;re missing some feature he&rsquo;s used to. But when our hypothetical Blub programmer looks in the other direction, up the power continuum, he doesn&rsquo;t realize he&rsquo;s looking up. What he sees are merely weird languages. He probably considers them about equivalent in power to Blub, but with all this other hairy stuff thrown in as well. Blub is good enough for him, because he thinks in Blub.</p>
</blockquote>

<p>So lets not be the Blub programmer, shall we. Today, we will jump directly into <strong>Functor</strong>. Trust me, its not that hard. We will even see Functors in Swift and create some more.</p>

<h1 id="intro">Intro</h1>

<p><strong>Functor</strong> is a container data type that provides an interface through which client can pass a function which will be applied to the items inside that container to produce a new container data type.</p>

<p>Lets see list: <code>Array&lt;Int&gt;</code>,
- Its a container data type. It can hold bunch of <code>Int</code>s.</p>

<h2 id="problem">Problem</h2>

<pre><code class="language-swift">let naturalNumbers = [1,2,3,4,5]
</code></pre>

<ol>
<li>Is there a way I can multiply the list of natural numbers by 2 to produce doubled list?</li>
<li>Is there a way I can take a list of natural numbers, apply a function and get back a list of string representing natural numbers?</li>
</ol>

<h2 id="solution">Solution</h2>

<p>Lets do the Imperative way:</p>

<pre><code class="language-swift">//1.
var output:[Int] = []
for n in naturalNumbers {
    let applied = n * 2
    output.append(applied)
}

//2.
var output: [String] = []
for n in naturalNumbers {
    let applied = String(n)
    output.append(applied)
}
</code></pre>

<p>What if we wanted to get squares of items in the list? Do we write another imperative code block:</p>

<pre><code class="language-swift">var output: [Int] = []
for n in naturalNumbers {
    let applied = n * n
    output.append(applied)
}
</code></pre>

<h3 id="criticizing">Criticizing:</h3>

<ol>
<li>We have a lot of repeating code, this is minor to the second point.</li>
<li>We are mutating output in every pass. What if this variable is declared 100 lines above the looping construct. What if other parts of code mutate this variable while we are trying to apply a function in loop.</li>
<li>We have a repeating code for a repeating pattern. Can we encapsulate what varies?</li>
</ol>

<h3 id="improvising-1">Improvising 1</h3>

<p>Lets try to encapsulate what varies. The right encapsulation here is a function. Naturally right!</p>

<pre><code class="language-swift">func something(input: [Int]) -&gt; [Int] {
    var output: [Int] = []
    for n in input {
        let applied = // what do we do here
        output.append(applied)
    }
    return output
}
</code></pre>

<p>The above code has 3 problems:</p>

<ol>
<li>What do we name the function?</li>
<li>If this function only works on <code>[Int]</code> then we need to write similar functions for other types we might want to compute.</li>
<li>do we know what function will be n applied to before hand?</li>
</ol>

<h3 id="improvising-2">Improvising 2</h3>

<p>Lets think for a moment on these 3 lines:</p>

<pre><code class="language-swift">let applied = n * 2
let applied = String(n)
let applied = n * n
</code></pre>

<p>We are transforming <code>n</code> into some other type by applying a function. <code>*</code> is a operator/function. <code>String()</code> is a constructor function.</p>

<p>Let&rsquo;s think more</p>

<ul>
<li>The function takes 1 parameter only which is <code>n</code></li>
<li>The function returns 1 value of any other type. The other type can be the same one as <code>n</code>.</li>
</ul>

<p>Can we generalize this three lines as a transform function:</p>

<pre><code class="language-swift">let applied = transform(n)
</code></pre>

<p>where transform would be (don&rsquo;t worry about the T and U. They are placeholder types):</p>

<pre><code>func transform&lt;T,U&gt;(input: T) -&gt; U

</code></pre>

<p>Now we know what applied is going to be: its a transform on the current value. Can we get this transform function as input to the function.</p>

<blockquote>
<p>Sure, swift has closures and higher order function.</p>
</blockquote>

<p>Lets get back to naming this; for starters we will call <code>map</code> (Its takes one type and maps to other)</p>

<pre><code class="language-swift">func map&lt;T, U&gt;(input: [T], transform: ((T) -&gt; U)) -&gt; [U] {
    var output: [U] = []
    for n in input {
        let applied = transform(n)
        output.append(applied)
    }
    return output
}
</code></pre>

<p>The above function is a map that takes input as List of <code>T</code> and a transform parameter of function type where the function takes <code>T</code> value and does something to return <code>U</code> kind value. We gather all the <code>U</code> values and return that.</p>

<p>Aha now we have a function that encapsulates the mutation. This function is capable of handling any types of list and any types of transform. 1 function to rule the transform. Nice, right.</p>

<p>Chances are you know this all by heart, this is the standard <code>map</code> function on Collection type of Swift.</p>

<p>Now lets go beyond the normal comfort zone. Do we need <code>map</code> or mapping only on List types. Turns out, especially in FP, maps are essential utility to convert one type to another. A lots of types can be mapped. There&rsquo;s another such type in Swift which has <code>map</code>; <strong>Optional</strong></p>

<p>What about Dictionary? They seem to be in need of <code>map</code>. Swift has this baked in.</p>

<p>What is this all for? In fact, we have just created a <strong>functor</strong>. In the example code above, List is a <strong>functor</strong> type.</p>

<pre><code class="language-swift">Array&lt;T&gt; =&gt; container of zero or more `T` typed items
Optional&lt;T&gt; = container of either .none or .some(T) 
Dictionary&lt;K,V&gt; = container of zero or more (K,V) pairs
</code></pre>

<p>These 3 types do provide a interface to supply transform function. Its called <code>map</code>.</p>

<p>Hence, We already have <strong>functors</strong> in swift but haven&rsquo;t realized we did. To make things easy, a type that can be mapped is a functor. However, for a type to be a functor it has to have these properties.</p>

<h1 id="properties">Properties</h1>

<pre><code>fmap :: (a -&gt; b) -&gt; f a -&gt; f b  //Haskell 
func map(inputFunctor: Functor&lt;T&gt;, transform: (T -&gt; U)) -&gt; Functor&lt;U&gt; //Pseudo Swift
</code></pre>

<p>Seems like we need a type <code>Functor</code> which is polymorphic in <code>T</code>. Remember until this point, we have 3 <code>map</code> functions on each <code>Collection</code> and <code>Optional</code> type. There is no rule that specifies that a new user type will be a functor or that type&rsquo;s <code>map</code> will abide by the law and do the right job. Its all informal conformance.</p>

<h1 id="laws">Laws</h1>

<p>Lets talk about the laws. There are only 2 laws for a type to be functor.</p>

<ol>
<li>If a Functor is applied with identity function it should be the same output.
```swift</li>
</ol>

<p>// Identity function in Haskell
id :: a -&gt; a
id x = x</p>

<p>// The identity function in swift
func id<T>(input: T) -&gt; T {
    return input
}</p>

<pre><code>
Now the identity law:
```swift
map(inputFunctor: [1,2,3,4], transform: id) == inputFunctor
</code></pre>

<p>which will result as these:</p>

<pre><code class="language-swift">var output: [Int] = []
for n in [1,2,3,4] {
    let applied = id(n)  // this `id` just returns what it was passed
    output.append(applied)
}
</code></pre>

<ol>
<li>Composing two functions and then mapping the resulting function over a Functor should be the same as first mapping one function over the functor and then mapping the other one.</li>
</ol>

<p>Before we can state and prove this law in swift, we need a function composition operator.</p>

<pre><code class="language-swift">infix operator &lt;&gt;

public func &lt;&gt; &lt;T,U, V&gt;(value1: @escaping((U) -&gt; V),  value2: @escaping ((T) -&gt; U)) -&gt; ((T)-&gt; V) {
    return { x in
        return value1(value2(x))
    }
}

</code></pre>

<p>The above function <code>&lt;&gt;</code> takes 2 function and combines into 1; the types should align.</p>

<p>Now lets see what it means:</p>

<pre><code class="language-swift">let mult2 = { x in x * 2 }
let mult3 = { x in x * 3 }

let x = map(inputFunctor: [1,2,3], transform: mult2 &lt;&gt; mult3)

let y1 = map(inputFunctor: [1,2,3], transform: mult3)
let y2 = map(inputFunctor: y1, transform: mult2)

x == y2
</code></pre>

<p>In Haskell this would be:</p>

<pre><code>map (f.g) = map f . map g
</code></pre>

<p>where <code>f</code> and <code>g</code> are functions and to <code>.</code> is equivalent to our <code>&lt;&gt;</code> operator.</p>

<p><em>Note: Haskell can infer types almost at all times leaving you to denote the type maybe on 1% case when ambiguity occurs. However, swift is verbose and can cause angle bracket blindness when using generics to provide type placeholder</em></p>

<h1 id="haskell">Haskell</h1>

<p>Functor definition</p>

<pre><code>class Functor f where
  fmap :: (a -&gt; b) -&gt; f a -&gt; f b
</code></pre>

<p>Notice Haskell uses <code>fmap</code> as the name of the method. We used <code>map</code> thats all okay. NOTE: <strong>class</strong> creates a type class which is not related anyway to class from OOP.</p>

<p>Lets create analogous data type to <code>Optional</code> from Swift in Haskell and conform it to be Functor.</p>

<pre><code>-- declaration
data Optional a = None | Some a

-- conformance to Functor
instance Functor Optional where
  fmap f None = None
  fmap f (Some a) = Some (f a)
</code></pre>

<h1 id="making-true-functor-type-in-swift">Making true Functor type in Swift</h1>

<p>Informal conformance is a weak promise that can be broken without consent. List, Optional , Dictionaries are Functor in Swift informally. There is no type guarantee. Lets make this <strong>Functor</strong> type and tie them once and for all.</p>

<h2 id="how-can-we-model-functor">How can we model Functor?</h2>

<p>Well, its a perfect candidate for Protocol. However, we will run into some limitation of Protocols in swift that will make us go the rough path. Modeling Functor with Struct is a bit easy but well, we cant conform List to a Struct! A class would work but but we want a lightweight interface.</p>

<p>Ideally, I wanted to express Functor like such</p>

<pre><code>protocol Functor&lt;A&gt; {
    func fmap(_ by: ((A) -&gt; B)) -&gt; Functor&lt;B&gt;
}
</code></pre>

<p>which is equivalent to Haskell&rsquo;s declaration of typeclass functor</p>

<pre><code>class Functor f where 
    fmap:: (a -&gt; b) -&gt; f a -&gt; f b
</code></pre>

<p>In Haskell, like other FP, a function can only take 1 parameter as input and return 1 parameter as output. Multi argument is achieved via function currying. So the above <code>fmap</code> is a function that take a function <code>a -&gt; b</code> and returns another function where <code>f a -&gt; f b</code>. Appreciate the fact that there is no clutter in the declaration site as the Haskell compiler knows how to curry functions and infer types. This makes writing Haskell so intuitive (once you get a hang of it).</p>

<p>Back to the point, the above Swift Functor declaration won&rsquo;t work because protocol cannot be them-self generic similar to</p>

<pre><code class="language-swift">struct Functor&lt;A&gt; {
    // struct can be generic in this way
}
</code></pre>

<p>To get a better grasp of why this is the limitation and how Haskell <strong>typeclass</strong> is superior to Swift&rsquo;s type system, I recommend reading this <a href="http://homepages.inf.ed.ac.uk/wadler/papers/class/class.ps">research paper on How to Make Ad-Hoc polymorphism less Ad-hoc</a>.</p>

<h2 id="improvising">Improvising</h2>

<p>Fortunately, protocol has associated types that can be used in our modeling case.</p>

<pre><code>public protocol Functor {
    associatedtype A
    func fmap&lt;F: Functor, B&gt;(_ by: ((A) -&gt; B)) -&gt; F where F.A == B
}
</code></pre>

<p>The above declaration states</p>

<ol>
<li>Current Functor is container of <code>A</code> types</li>
<li>fmap is a function that works on current functor</li>
<li>fmap takes a transform function <code>A -&gt; B</code> where input is <code>A</code>: current functor item type</li>
<li>fmap returns a Functor <code>F</code> whose <code>A</code> is equal to <code>B</code> that is emitted by transform function</li>
</ol>

<p>Its bit verbose and angle bracketed but it does the work.</p>

<h2 id="conforming-list-to-functor">Conforming List to Functor</h2>

<p>Time to conform Array<Element> to be Functor.</p>

<pre><code class="language-swift">extension Array: Functor {
    public typealias A = Element  // 1

    public func fmap&lt;F, B&gt;(_ by: ((Element) -&gt; B)) -&gt; F where F : Functor, B == F.A {
        var accumulator = [B]()
        for index in self {
            accumulator.append(by(index))
        }
        return accumulator as! F   // 2
    }

}
</code></pre>

<p>Couple of things to keep in mind:</p>

<ol>
<li>Array has a Element associated type which will be the real item model type. We will use that to denote Functor&rsquo;s Item Type. This is analogous to <code>Array&lt;Element&gt; ~~~ Functor&lt;Element&gt;</code></li>
<li>note that we down-casted forcefully to produce a Functor. It wont crash as we just conformed list to be Functor. This is just getting around invented type system.</li>
</ol>

<h2 id="taking-array-functor-for-a-spin">Taking Array Functor for a spin</h2>

<p>Lets see the Array Functor in action; shall we!</p>

<pre><code class="language-swift">let inputFunctor = [1,2,3]

// 1. See the implicit type annotation
let composedAppliedFunctor: Array&lt;Int&gt; = inputFunctor.fmap(mult2 &lt;&gt; mult3)

// returns [6, 12, 18] 
</code></pre>

<p>To see more example and documented source code; please check this <a href="https://github.com/kandelvijaya/SwiftFunctor">Github Repo: SwiftFunctor</a></p>

<h2 id="conforming-optional-to-functor">Conforming Optional To Functor</h2>

<p>Optional is a bit tricky to conform to Functor. First lets see the code and we shall see why exactly?</p>

<pre><code class="language-swift">extension Optional: Functor {

    // 1. 
    public typealias A = Wrapped

    public func fmap&lt;F, B&gt;(_ by: ((Wrapped) -&gt; B)) -&gt; F where F : Functor, B == F.A {
        switch self {
        case .none:
            //2. This will Crash
            return Optional&lt;B&gt;.none as! F
        case .some(let v):
            let fv = by(v)
            //3. This wont crash
            return Optional&lt;B&gt;(fv) as! F
        }
    }

}
</code></pre>

<p>Things to note:</p>

<ol>
<li><code>Optional&lt;Wrapped&gt;~~~~Functor&lt;Wrapped&gt;</code></li>
<li><code>.none</code> cannot be casted to Functor because <code>!</code> operator is defined on Optional such that it unwraps the eventual value from optional. In our case, its <code>.none</code> so it will crash. Think of doing this: <code>let a: Int? = nil</code> then <code>a! + 2</code>.</li>
<li>This wont crash because we do have something.</li>
</ol>

<p>Hence, <strong>Optional<Wrapped></strong>  cannot be represented as true Functor. It only works on happy case. This is the power of formal conformance.</p>

<h3 id="can-we-model-optional-somehow-to-be-functor">Can we model Optional somehow to be Functor?</h3>

<p>We can by using another wrapper type that is <strong><code>Maybe</code></strong> type.</p>

<pre><code class="language-swift">public struct Maybe&lt;T&gt; {
    //1. 
    public let value: Optional&lt;T&gt;

    public init() {
        value = .none
    }

    public init(with: T) {
        value = .some(with)
    }

}
</code></pre>

<p>Notes:</p>

<ol>
<li>We encapsulate the real optional inside a <strong>Maybe</strong> struct.</li>
</ol>

<p>Conforming to Functor is pretty similar as:</p>

<pre><code class="language-swift">extension Maybe: Functor {

    public func fmap&lt;F, B&gt;(_ by: ((T) -&gt; B)) -&gt; F where F : Functor, F.A == B {
        switch self.value {
        case .none:
            //1. Wont crash
            return Maybe&lt;B&gt;() as! F
        case .some(let v):
            //2. 
            let newv = by(v)
            return Maybe&lt;B&gt;(with: newv) as! F
        }
    }
    
}
</code></pre>

<p>Points to consider:</p>

<ol>
<li>Immediately we see that when we have <code>.none</code> value we return a empty <code>Maybe</code> type. This now doesn&rsquo;t crash.</li>
</ol>

<h1 id="conclusion">Conclusion</h1>

<p>To summarize:</p>

<ol>
<li><strong>Functor</strong> is a type that provides <code>mapping</code> capability. A type that can be mapped.</li>
<li>Swift has <strong>Collection</strong> and <strong>Optional</strong> types which are Functor. (Optional  is not pure Functor and we saw why.)</li>
<li>Functor are useful abstraction that can turn one kind of data into another.</li>
<li>Check out this <a href="https://github.com/kandelvijaya/SwiftFunctor">Github Repo &amp; Playground: SwiftFunctor</a> for updates and implementation details.</li>
<li>Functional Programming is scrutinizing pure function to produce mathematically provable, robust and compose-able software. FP is on the rise.</li>
<li>Don t get stuck on <strong>Blub Paradox</strong></li>
</ol>

<h1 id="whats-next">Whats next:</h1>

<ol>
<li>Next issue will go deep into what a total pure function is.</li>
<li>What is referential transparency.</li>
<li>OOh!!!! This should be pretty awesome.
Lets say a functor has a partially applied function inside it like <code>Some (*3)</code>and we have <code>Some(4)</code>, can we map this partially applied function over a data type. Yes, we will see <strong>Applicative Functor</strong> next time around.</li>
</ol>

<h1 id="references">References:</h1>

<ol>
<li>SwiftFunctor <a href="https://github.com/kandelvijaya/SwiftFunctor">Github Repo</a></li>
<li>Why Functional Programming Matters? <a href="https://www.cs.kent.ac.uk/people/staff/dat/miranda/whyfp90.pdf">Paper</a></li>
<li>Blub Paradox <a href="http://wiki.c2.com/?BlubParadox">Article</a></li>
<li>Learn you a Haskell for Great Good <a href="http://learnyouahaskell.com">Book</a></li>
<li>How to make Ad-Hoc polymorphism less ad-hoc <a href="https://people.csail.mit.edu/dnj/teaching/6898/papers/wadler88.pdf">Paper</a></li>
<li>Why FP matters? <a href="http://book.realworldhaskell.org/read/why-functional-programming-why-haskell.html">e book</a></li>
</ol>

<p><em>Happy Coding.</em>
<em>Cheers!</em></p>

</div>

        <footer class="post-footer clearfix">
    
        <p class="post-tags">
            <span>Tagged:</span>
            
            
                <a href="/tags/haskell/">haskell</a>, 
            
                <a href="/tags/swift3/">swift3</a>, 
            
                <a href="/tags/functional-programming/">functional programming</a>, 
            
                <a href="/tags/fp/">fp</a>
            
        </p>
    

    <div class="share">
        
            <a class="icon-twitter" href="https://twitter.com/share?text=Functor%3a%20Mapping%20over%20things%21&url=http%3a%2f%2fkandelvijaya.com%2f2017%2f05%2f28%2ffp-functor%2f"
                onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;">
                <i class="fa fa-twitter"></i>
                <span class="hidden">Twitter</span>
            </a>
        

        
            <a class="icon-facebook" href="https://www.facebook.com/sharer/sharer.php?u=http%3a%2f%2fkandelvijaya.com%2f2017%2f05%2f28%2ffp-functor%2f"
                onclick="window.open(this.href, 'facebook-share','width=580,height=296');return false;">
                <i class="fa fa-facebook"></i>
                <span class="hidden">Facebook</span>
            </a>
        

        
            <a class="icon-google-plus" href="https://plus.google.com/share?url=http%3a%2f%2fkandelvijaya.com%2f2017%2f05%2f28%2ffp-functor%2f"
              onclick="window.open(this.href, 'google-plus-share', 'width=490,height=530');return false;">
              <i class="fa fa-google-plus"></i>
                <span class="hidden">Google+</span>
            </a>
        
        
    </div>
</footer>

        
    <div class="comments">
        <div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'kandelvijayacom';
    var disqus_identifier = 'http:\/\/kandelvijaya.com\/2017\/05\/28\/fp-functor\/';
    var disqus_title = 'Functor: Mapping over things!';
    var disqus_url = 'http:\/\/kandelvijaya.com\/2017\/05\/28\/fp-functor\/';

    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>

    </article>
</div>

            </div>
        </div>

        <footer class="footer">
            <div class="container">
                <div class="site-title-wrapper">
                    <h1 class="site-title">
                        <a title="Kandelvijaya" href="http://kandelvijaya.com/">Kandelvijaya</a>
                    </h1>
                    <a class="button-square button-jump-top js-jump-top" href="#">
                        <i class="fa fa-angle-up"></i>
                    </a>
                </div>

                <p class="footer-copyright">
                    <span>&copy; 2017 / Powered by <a href="https://gohugo.io/">Hugo</a></span>
                </p>
                <p class="footer-copyright">
                    <span><a href="https://github.com/roryg/ghostwriter">Ghostwriter theme</a> By <a href="http://jollygoodthemes.com">JollyGoodThemes</a></span>
                    <span>/ <a href="https://github.com/jbub/ghostwriter">Ported</a> to Hugo By <a href="https://github.com/jbub">jbub</a></span>
                </p>
            </div>
        </footer>

        <script src="http://kandelvijaya.com/js/jquery-1.11.3.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/highlight.min.js"></script>
        <script src="http://kandelvijaya.com/js/jquery.fitvids.js"></script>
        <script src="http://kandelvijaya.com/js/scripts.js"></script>
    </body>
</html>

